package beast.evolution.tree;

import beast.core.Description;
import beast.core.Input;
import beast.evolution.alignment.Alignment;
import beast.evolution.alignment.TaxonSet;

import java.util.*;

/**
 * User: joseph
 * Date: 11/08/14
 */

@Description("The binary tree generated by pruning a fixed subset of taxa from a source binary tree.")
public class PrunedTree extends Tree {
    public Input<Tree> m_tree = new Input<Tree>("tree", "source tree to filter/prune.");
    public Input<Alignment> m_alignment = new Input<>("alignment", "take taxa of pruned tree from alignment");

    public Input<Boolean> m_fast = new Input<>("quickshortcut", "Detect pruned tree change in two stages." +
            "the first stage requires that all tree operators mark all changed clades (markclades=true in tree " +
            "operator.", false);

     public Input<Boolean> m_assert = new Input<>("assert", "perform expensive consistency checks (but only with" +
             " -ea)",
             true);

    private int[] leafsToBaseLeafs;
    // -1
    private int[] baseLeafsToLeafs;

    // save on re-allocs. share
    private Node[/* #source tree nodes */] sourceNodesPreOrder;
    private boolean[/* #source tree nodes */] seen;

    // disable expensive asserts even with -ea.
    // set to false for production system, when debugging is over
    private boolean expensiveAsserts = true;

    private boolean fast;

    public PrunedTree() {}

    @Override
    public void initAndValidate() throws Exception {
        expensiveAsserts = m_assert.get();

        final Tree tree = m_tree.get();
        final TaxonSet treeTaxa = tree.getTaxonset();
        final Alignment alignment = m_alignment.get();
        List<String> taxaNames;

        if( alignment != null  ) {
            taxaNames = alignment.getTaxaNames();
        } else {
            final TaxonSet taxa = m_taxonset.get();
            taxaNames = taxa.asStringList();
        }

        if( ! treeTaxa.containsAll(taxaNames) ) {
            throw new Exception("Taxa is not a subset of base tree taxa.");
        }

        final int nTaxa = taxaNames.size();

        leafsToBaseLeafs = new int[nTaxa];
        baseLeafsToLeafs  = new int[treeTaxa.getTaxonCount()];
        Arrays.fill(baseLeafsToLeafs, -1);

        root = initTree(tree, taxaNames);
        leafNodeCount = nTaxa;
        nodeCount = leafNodeCount * 2 - 1;
        internalNodeCount = leafNodeCount - 1;

        sourceNodesPreOrder = new Node[tree.getNodeCount()];
        seen = new boolean[tree.getNodeCount()];

        super.initAndValidate();

        fast = m_fast.get();
//
//        if( getState() != null ) {
//            throw new Exception("Get filtered tree out of state please.");
//        }
    }

    private Node initTree(TreeInterface tree, List<String> taxaNames) {
        Set<String> tax = new HashSet<>(taxaNames);
        final int nTaxa = taxaNames.size();
        int[] nodeNumber2Source = new int[2*nTaxa-1];
        Node[] nodes = new Node[2*nTaxa-1];
        Node root = buildTree(tree.getRoot(), tax, new MyInt(0), new MyInt(taxaNames.size()),
                              nodes, nodeNumber2Source);

        // insure that node numbers are consistent over stop and resume.
        // Node numbers are assigned so that their sort order is identical to the sort
        // order of their source nodes.

        // i = 0..nTaxa-1
        final Integer[] i = new Integer[nodeNumber2Source.length];
        for(int k = 0; k < i.length; ++k) { i[k] = k; }

        Arrays.sort(i, (o1, o2) -> nodeNumber2Source[o1] - nodeNumber2Source[o2]);
        for(int k = 0; k < i.length; ++k) {
            nodes[k].setNr(k);
            assert nodes[k].isLeaf() == k < nTaxa;
        }

        return root;
    }

    // int by reference, java style
    private class MyInt {
        MyInt(int k) {
            n = k;
        }
        public int n;
    }

    private Node buildTree(Node base, Set<String> taxaNames, MyInt leafNodeCount, MyInt internalNodeCount,
                           Node[] nodes, int[] nodeNumber2Source) {
        Node n;
        if( base.isLeaf() ) {
            if( taxaNames.contains(base.getID()) ) {
                n = newNode();
                n.setNr(leafNodeCount.n);
                leafsToBaseLeafs[leafNodeCount.n] = base.getNr();
                baseLeafsToLeafs[base.getNr()] = leafNodeCount.n;

                leafNodeCount.n += 1;
                n.setID(base.getID());
            } else {
                n = null;
            }
        } else {
            Node left  = buildTree(base.getLeft(),  taxaNames, leafNodeCount, internalNodeCount,
                                   nodes, nodeNumber2Source);
            Node right = buildTree(base.getRight(), taxaNames, leafNodeCount, internalNodeCount,
                                   nodes, nodeNumber2Source);
            if( left == null ) {
                return right;
            }
            if( right == null ) {
                return left;
            }
            n = newNode();
            n.setNr(internalNodeCount.n);
            internalNodeCount.n += 1;
            n.setLeft(left);
            n.setRight(right);
            left.setParent(n, false);
            right.setParent(n, false);
        }

        if( n != null ) {
            n.setHeight(base.getHeight());
            nodes[n.getNr()] = n;
            nodeNumber2Source[n.getNr()] = base.getNr();
        }
        return n;
    }

    private boolean anyChange() {
        final Tree tree = m_tree.get();
        //boolean[] seen = new boolean[tree.getNodeCount()];
        Arrays.fill(seen, false);

        for( int nr : leafsToBaseLeafs ) {
            Node n = tree.getNode(nr);
            if( n.isDirty() != Tree.IS_CLEAN ) {
                return true;
            }
            n = n.parent;
            while( n != null ) {
                final int k = n.getNr();
                if( ! seen[k] ) {
                  seen[k] = true;
                } else {
                    if( n.isDirty() != Tree.IS_CLEAN ) {
                        return true;
                    }
                    break;
                }
                n = n.parent;
            }
        }
        return false;
    }

    private boolean anyChangeSlow() {
        final Tree tree = m_tree.get();
        int[] has = new int[tree.getNodeCount()];
        System.arraycopy(baseLeafsToLeafs, 0, has, 0, baseLeafsToLeafs.length);

        Node[] post = tree.listNodesPostOrder(null, sourceNodesPreOrder);
        for (int k = 0; k < post.length; ++k) {
            final Node n = post[k];
            final int nr = n.getNr();
            if( n.isLeaf() ) {
                if( has[nr] != -1 && n.isDirty() != Tree.IS_CLEAN ) {
                    return true;
                }
            } else {
                final int l = has[n.getLeft().getNr()];
                final int r = has[n.getRight().getNr()];
                if( l >= 0 && r >= 0 ) {
                    if( n.isDirty() != Tree.IS_CLEAN ) {
                        return true;
                    }
                }
                has[nr] = Math.max(l, r);
            }
        }
        return false;
    }

    // counts for debugging
    int countTot = 0;
    int skipX = 0;
    int skipY = 0;

    boolean first = true;

    @Override
    protected boolean requiresRecalculation() {
        return rq();
    }
    // for stupid profiler to count it here and not against caller
    private boolean rq() {
        countTot += 1;

        if( fast ) {
            final boolean any = anyChange();
            ;                                                  if( expensiveAsserts ) { assert any == anyChangeSlow(); }
            // this is not a state node. nobody resets dirty flags for us
            setEverythingDirty(false);

            if( !any ) {
                ;                               if( expensiveAsserts ) { assert validFilteredTree(this, m_tree.get()); }
                skipX += 1;
                return false;
            }
        }
        // Traverse the tree and reconstruct pruned tree when detecting a change.
        // Traverse source tree in post-order (children before parents)
        // if both children unmapped -> unmapped
        // if one child mapped -> steal map
        // if both:
        //   if target parents equal - map to that parent (if height changed set dirty)
        //   if not, pick lower parent (the taller parent is never in the subtree of the other (lower) parent
        //   exchange child of upper with other child of lower. map to lower parent.

        final Tree tree = m_tree.get();

        //Node[] post = sourceNodesPreOrder; // with slow version
        Node[] post = tree.listNodesPostOrder(null, sourceNodesPreOrder);

        // counts (i.e. tree taxa) are assumed not to change
        Node[] map = new Node [tree.nodeCount]; //getNodeCount()];
        int[] mapped = new int [nodeCount]; // getNodeCount()];
        int nm = 0;

        boolean anyChanges = false;

        for (final Node n : post) {
            final int nr = n.getNr();

            if( n.isLeaf() ) {
                final int iLeaf = baseLeafsToLeafs[nr];
                if( iLeaf < 0 ) {
                    map[nr] = null;
                } else {
                    map[nr] = getNode(iLeaf);
                }
            } else {
                // internal
                final Node l = n.getLeft();
                final Node r = n.getRight();

                final int iLeft = l.getNr();
                final int iRight = r.getNr();

                Node mLeft = map[iLeft];
                Node mRight = map[iRight];

                if( mLeft == null ) {
                    map[nr] = mRight;
                } else if( mRight == null ) {
                    map[nr] = mLeft;
                } else {
                    // both mapped
                    Node pLeft = mLeft.getParent();
                    Node pRight = mRight.getParent();

                    if( pLeft == pRight ) {
                        map[nr] = pLeft;
                    } else {
                        anyChanges = true;

                        if( pLeft.getHeight() > pRight.getHeight() ) {
                            Node tmp = pLeft;
                            pLeft = pRight;
                            pRight = tmp;
                            tmp = mLeft;
                            mLeft = mRight;
                            mRight = tmp;
                            // iLeft ??
                            //assert false;
                        }
                        assert pLeft.getHeight() <= pRight.getHeight();
                        // exchange left subtree
                        final int other = (pLeft.getChild(0) == mLeft) ? 1 : 0;
                        Node o = pLeft.getChild(other);
                        pLeft.setChild(other, mRight);
                        mRight.parent = pLeft;

                        pLeft.makeDirty(Tree.IS_FILTHY);
                        mRight.makeDirty(Tree.IS_FILTHY);

                        final int rSelf = (pRight.getChild(0) == mRight) ? 0 : 1;
                        pRight.setChild(rSelf, o);
                        o.parent = pRight;

                        pRight.makeDirty(Tree.IS_FILTHY);
                        o.makeDirty(Tree.IS_FILTHY);

                        map[nr] = pLeft;
                    }
                    mapped[nm] = nr;
                    nm += 1;
                }
            }
        }

        if( root != map[mapped[nm-1]] ) {
            setRoot(map[mapped[nm-1]]);
            anyChanges = true;
        }

        for(int k = 0; k < nm; ++k) {
            final int nr = mapped[k];
            final Node n = tree.getNode(nr);
            final Node to = map[nr];
            if( n.getHeight() != to.getHeight() ) {
                to.setHeight(n.getHeight());
                anyChanges = true;
            }
        }

        ;                                             if( expensiveAsserts ) {  validFilteredTree(this, m_tree.get()); }

        // node is dirty but only branch length to parent changed, and parent is not part of pruned tree.
        // too many marked nodes (bugs)
        if( !anyChanges && !first ) {
            skipY += 1;
            return false;
        }
        first = false;
        hasStartedEditing = true; // make dirty for users
        return true;
    }

    //private boolean isReady = true;

    private boolean storeCalledThisCycle = false;

    protected void store() {
        //assert isReady;
        //isReady = false;
        if( ! storeCalledThisCycle ) {
            super.store();
        }
        storeCalledThisCycle = true;
    }

    protected void accept() {
        //assert isReady;
        storeCalledThisCycle = false;
        super.accept();
    }

    public void restore() {
        // assert isReady;
        storeCalledThisCycle = false;
        super.restore();
    }

    static boolean validFilteredTree(TreeInterface pruned, TreeInterface source)  {
        Node[] post = source.listNodesPostOrder(null, null);

        Map<String,Node> taxaMap = new HashMap<>();

        for( Node n : pruned.getExternalNodes() ) {
            taxaMap.put(n.getID(), n);
        }
        Node[] map = new Node[source.getNodeCount()];


        for (final Node n : post) {
            final int nr = n.getNr();

            if( n.isLeaf() ) {
                Node m = taxaMap.get(n.getID());
                if( m == null ) {
                    // not
                    map[nr] = null;
                } else {
                    map[nr] = m;
                }
            } else {
                // internal
                final Node l = n.getLeft();
                final Node r = n.getRight();

                final int iLeft = l.getNr();
                final int iRight = r.getNr();

                Node mLeft = map[iLeft];
                Node mRight = map[iRight];

                if( mLeft == null ) {
                    map[nr] = mRight;
                } else if( mRight == null ) {
                    map[nr] = mLeft;
                } else {
                    // both mapped
                    Node pLeft = mLeft.getParent();
                    Node pRight = mRight.getParent();

                    if( pLeft != pRight ) {
                        return false;
                    }
                    if( n.getHeight() != pLeft.getHeight() ) {
                        return false;
                    }
                    map[nr] = pLeft;
                }
            }
        }
        return true;
    }
}
