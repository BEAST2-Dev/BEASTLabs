package beast.evolution.tree;

import beast.core.Description;
import beast.core.Input;
import beast.evolution.alignment.Alignment;
import beast.evolution.alignment.TaxonSet;

import java.util.*;

/**
 * User: joseph
 * Date: 11/08/14
 */

@Description("The binary tree generated by pruning a fixed subset of taxa from a source binary tree.")
public class PrunedTree extends Tree {
    public Input<Tree> m_tree = new Input<Tree>("tree", "source tree to filter/prune.");
    public Input<Alignment> m_alignment = new Input<Alignment>("alignment", "take taxa of pruned tree from alignment");

    public Input<Boolean> m_fast = new Input<>("quickshortcut", "Detect pruned tree change in two stages." +
            "the first stage requires that all tree operators mark all changed clades (markclades=true in tree " +
            "operator.", false);

    public Input<Boolean> m_assert = new Input<>("assert", "perform expensive consistency checks (but only with" +
            " -ea)", false);

    private int[] leafsToBaseLeafs;
    // -1
    private int[] baseLeafsToLeafs;

    // save on re-allocs. share
    private Node[/* #source tree nodes */] sourceNodesPreOrder;
    private boolean[/* #source tree nodes */] seen;

    // disable expensive asserts even with -ea.
    // set to false for production system, when debugging is over
    private boolean expensiveAsserts = true;

    private boolean fast;

    private int[] nodeNumberToBase;

    private boolean trackInternalPathChanges = false;
    private int[] nodeNumberToBaseStore = null;
    private boolean[] baseNodesOnPrunedPath = null;
    //private boolean[] baseNodesOnPrunedPathHelper = null;
    private boolean anyPathChanges = false;

    public PrunedTree() {
    }

    @Override
    public void initAndValidate() {
        expensiveAsserts = m_assert.get();

        final Tree tree = m_tree.get();
        final TaxonSet treeTaxa = tree.getTaxonset();
        final Alignment alignment = m_alignment.get();
        List<String> taxaNames;

        if( alignment != null ) {
            taxaNames = alignment.getTaxaNames();
        } else {
            final TaxonSet taxa = m_taxonset.get();
            taxaNames = taxa.asStringList();
        }

        if( !treeTaxa.containsAll(taxaNames) ) {
            throw new IllegalArgumentException("Taxa is not a subset of base tree taxa.");
        }

        final int nTaxa = taxaNames.size();

        leafsToBaseLeafs = new int[nTaxa];
        baseLeafsToLeafs = new int[treeTaxa.getTaxonCount()];
        Arrays.fill(baseLeafsToLeafs, -1);

        root = initTree(tree, taxaNames);
        leafNodeCount = nTaxa;
        nodeCount = leafNodeCount * 2 - 1;
        internalNodeCount = leafNodeCount - 1;

        sourceNodesPreOrder = new Node[tree.getNodeCount()];
        seen = new boolean[tree.getNodeCount()];

        nodeNumberToBase = new int[nodeCount];
        nodeNumberToBaseStore = null ; // new int[nodeCount];

        super.initAndValidate();

        fast = m_fast.get();

        System.arraycopy(leafsToBaseLeafs, 0, nodeNumberToBase, 0, leafsToBaseLeafs.length);
//
//        if( getState() != null ) {
//            throw new Exception("Get filtered tree out of state please.");
//        }
    }

    private Node initTree(TreeInterface tree, List<String> taxaNames) {
        Set<String> tax = new HashSet<>(taxaNames);
        final int nTaxa = taxaNames.size();
        int[] nodeNumber2Source = new int[2 * nTaxa - 1];
        Node[] nodes = new Node[2 * nTaxa - 1];
        Node root = buildTree(tree.getRoot(), tax, new MyInt(0), new MyInt(taxaNames.size()),
                nodes, nodeNumber2Source);

        // insure that node numbers are consistent over stop and resume.
        // Node numbers are assigned so that their sort order is identical to the sort
        // order of their source nodes.

        // i = 0..nTaxa-1
        final Integer[] i = new Integer[nodeNumber2Source.length];
        for (int k = 0; k < i.length; ++k) {
            i[k] = k;
        }

        Arrays.sort(i, (o1, o2) -> nodeNumber2Source[o1] - nodeNumber2Source[o2]);
        for (int k = 0; k < i.length; ++k) {
            nodes[k].setNr(k);
            assert nodes[k].isLeaf() == k < nTaxa;
        }

        return root;
    }

    public void keepTrack() {
        trackInternalPathChanges = true;
        nodeNumberToBaseStore = new int[nodeCount];
        baseNodesOnPrunedPath = new boolean[seen.length];
        //baseNodesOnPrunedPathHelper =  new boolean[seen.length];
    }

    // int by reference, java style. Isn't Java the best language *ever*
    private class MyInt {
        MyInt(int k) {
            n = k;
        }

        public int n;
    }

    private Node buildTree(Node base, Set<String> taxaNames, MyInt leafNodeCount, MyInt internalNodeCount,
                           Node[] nodes, int[] nodeNumber2Source) {
        Node n;
        if( base.isLeaf() ) {
            if( taxaNames.contains(base.getID()) ) {
                n = newNode();
                n.setNr(leafNodeCount.n);
                leafsToBaseLeafs[leafNodeCount.n] = base.getNr();
                baseLeafsToLeafs[base.getNr()] = leafNodeCount.n;

                leafNodeCount.n += 1;
                n.setID(base.getID());
            } else {
                n = null;
            }
        } else {
            Node left = buildTree(base.getLeft(), taxaNames, leafNodeCount, internalNodeCount,
                    nodes, nodeNumber2Source);
            Node right = buildTree(base.getRight(), taxaNames, leafNodeCount, internalNodeCount,
                    nodes, nodeNumber2Source);
            if( left == null ) {
                return right;
            }
            if( right == null ) {
                return left;
            }
            n = newNode();
            n.setNr(internalNodeCount.n);
            internalNodeCount.n += 1;
            n.setLeft(left);
            n.setRight(right);
            left.setParent(n, false);
            right.setParent(n, false);
        }

        if( n != null ) {
            n.setHeight(base.getHeight());
            nodes[n.getNr()] = n;
            nodeNumber2Source[n.getNr()] = base.getNr();
        }
        return n;
    }

    private boolean anyChange() {
        if( trackInternalPathChanges ) {
            //
            final boolean any = anyChangeFull();
            anyPathChanges = any;
            return any;
        }

        final Tree tree = m_tree.get();
        //boolean[] seen = new boolean[tree.getNodeCount()];
        Arrays.fill(seen, false);

        for (int nr : leafsToBaseLeafs) {
            Node n = tree.getNode(nr);
            if( n.isDirty() != Tree.IS_CLEAN ) {
                return true;
            }
            n = n.parent;
            while (n != null) {
                final int k = n.getNr();
                if( !seen[k] ) {
                    seen[k] = true;
                } else {
                    if( n.isDirty() != Tree.IS_CLEAN ) {
                        return true;
                    }
                    break;
                }
                n = n.parent;
            }
        }
        return false;
    }

    private void fillRestOfBaseNodesOnPath(int i, double h, Node last, final Tree tree) {
        for (/**/; i <  leafsToBaseLeafs.length; ++ i) {
            final int nr = leafsToBaseLeafs[i];
            Node n = tree.getNode(nr);
            baseNodesOnPrunedPath[n.getNr()] = true;
            n = n.parent;
            while (n != null) {
                final int k = n.getNr();
                baseNodesOnPrunedPath[k] = true;
                if( !seen[k] ) {
                    seen[k] = true;
                } else {
                    final double height = n.getHeight();
                    if( height > h ) {
                        last = n;
                        h = height;
                    }
                    break;
                }
                n = n.parent;
            }
        }
        {
            // now check all nodes on the path of the first tip, until MRCA of all pruned tips
            int nr0 = leafsToBaseLeafs[0];
            Node n = tree.getNode(nr0);
            baseNodesOnPrunedPath[n.getNr()] = true;
            n = n.parent;
            while (n != null) {
                baseNodesOnPrunedPath[n.getNr()] = true;
                if( n == last ) {
                    break;
                }
                n = n.parent;
            }
        }
    }

    private boolean anyChangeFull() {
        final Tree tree = m_tree.get();

        Arrays.fill(seen, false);
       // boolean[] save = baseNodesOnPrunedPath;
       // baseNodesOnPrunedPath = baseNodesOnPrunedPathHelper;
       // baseNodesOnPrunedPathHelper = save;

        Arrays.fill(baseNodesOnPrunedPath, false);
        boolean dirty;
        {
            // for the first tip, mark as seen all nodes on the path to the root.
            // adding to "on-path" set happens only after we figure out the true root
            final int nr0 = leafsToBaseLeafs[0];
            Node n = tree.getNode(nr0);
            dirty = (n.isDirty() != Tree.IS_CLEAN);

            //baseNodesOnPrunedPath[n.getNr()] = true;
            n = n.parent;
            while (n != null) {
                final int k = n.getNr();                                           assert !seen[k];
                seen[k] = true;
                n = n.parent;
            }
        }
        if( dirty ) {
            fillRestOfBaseNodesOnPath(1, -1, null, tree);
            return true;
        }

        double h = -1;
        Node last = null;
        for (int i = 1; i <  leafsToBaseLeafs.length; ++ i) {
            final int nr = leafsToBaseLeafs[i];
            Node n = tree.getNode(nr);
            baseNodesOnPrunedPath[nr] = true;

            if( n.isDirty() != Tree.IS_CLEAN ) {
                fillRestOfBaseNodesOnPath(i, h, last, tree);
                return true;
            }
            n = n.parent;
            while (n != null) {
                final int k = n.getNr();
                if( n.isDirty() != Tree.IS_CLEAN ) {
                    fillRestOfBaseNodesOnPath(i, h, last, tree);
                    return true;
                }
                baseNodesOnPrunedPath[k] = true;
                if( !seen[k] ) {
                    seen[k] = true;
                } else {
                    final double height = n.getHeight();
                    if( height > h ) {
                        last = n;
                        h = height;
                    }
                    break;
                }
                n = n.parent;
            }
        }
        {
            // now check all nodes on the path of the first tip, until MRCA of all pruned tips
            int nr0 = leafsToBaseLeafs[0];
            Node n = tree.getNode(nr0);
            baseNodesOnPrunedPath[nr0] = true;
            n = n.parent;
            while (n != null) {
                //final int k = n.getNr();
                baseNodesOnPrunedPath[n.getNr()] = true;
                dirty = dirty || ( n.isDirty() != Tree.IS_CLEAN );
                if( n == last ) {
                    break;
                }
                n = n.parent;
            }
        }
        return dirty;
    }

    private boolean anyChangeSlow() {
        final Tree tree = m_tree.get();
        int[] has = new int[tree.getNodeCount()];
        System.arraycopy(baseLeafsToLeafs, 0, has, 0, baseLeafsToLeafs.length);

        Node[] post = tree.listNodesPostOrder(null, sourceNodesPreOrder);
        for (final Node n : post) {
            final int nr = n.getNr();
            if( n.isLeaf() ) {
                if( has[nr] != -1 && n.isDirty() != Tree.IS_CLEAN ) {
                    return true;
                }
            } else {
                final int l = has[n.getLeft().getNr()];
                final int r = has[n.getRight().getNr()];
                if( l >= 0 && r >= 0 ) {
                    if( n.isDirty() != Tree.IS_CLEAN ) {
                        return true;
                    }
                }
                has[nr] = Math.max(l, r);
            }
        }
        return false;
    }

    // counts for debugging
    int countTot = 0;
    int skipX = 0;
    int skipY = 0;

    boolean first = true;

    @Override
    protected boolean requiresRecalculation() {
        return rq();
    }
    // for stupid profiler to count time of above against us and not against caller
    private boolean rq() {
        countTot += 1;

        if (leafNodeCount == 1) {
            return false;
        }

        if( fast || trackInternalPathChanges ) {
            final boolean any = anyChange();
            ;                                                  if( expensiveAsserts && !trackInternalPathChanges) { assert any == anyChangeSlow(); }
            ;                                                  // need to fix anyChangeSlow
            // this is not a state node. nobody resets dirty flags for us
            // possible bug? - what happens when !fast
            setEverythingDirty(false);

            if( !any ) {
                ;                               if( expensiveAsserts ) { assert validFilteredTree(this, m_tree.get()); }
                skipX += 1;
                return false;
            }
        }
        // Traverse the tree and reconstruct pruned tree when detecting a change.
        // Traverse source tree in post-order (children before parents)
        // if both children unmapped -> unmapped
        // if one child mapped -> steal map
        // if both:
        //   if target parents equal - map to that parent (if height changed set dirty)
        //   if not, pick lower parent (the taller parent is never in the subtree of the other (lower) parent
        //   exchange child of upper with other child of lower. map to lower parent.

        final Tree tree = m_tree.get();

        //Node[] post = sourceNodesPreOrder; // with slow version
        Node[] post = tree.listNodesPostOrder(null, sourceNodesPreOrder);

        // counts (i.e. tree taxa) are assumed not to change
        Node[] map = new Node [tree.nodeCount]; //getNodeCount()];
        int[] mapped = new int [nodeCount]; // getNodeCount()];
        int nm = 0;

        boolean anyChanges = false;

        for (final Node n : post) {
            final int nr = n.getNr();

            if( n.isLeaf() ) {
                final int iLeaf = baseLeafsToLeafs[nr];
                if( iLeaf < 0 ) {
                    map[nr] = null;
                } else {
                    map[nr] = getNode(iLeaf);
                }
            } else {
                // internal
                final Node l = n.getLeft();
                final Node r = n.getRight();

                final int iLeft = l.getNr();
                final int iRight = r.getNr();

                Node mLeft = map[iLeft];
                Node mRight = map[iRight];

                if( mLeft == null ) {
                    map[nr] = mRight;
                } else if( mRight == null ) {
                    map[nr] = mLeft;
                } else {
                    // both mapped
                    Node pLeft = mLeft.getParent();
                    Node pRight = mRight.getParent();

                    if( pLeft == pRight ) {
                        map[nr] = pLeft;
                    } else {
                        anyChanges = true;
                        insureStore();

                        if( pLeft.getHeight() > pRight.getHeight() ) {
                            Node tmp = pLeft;
                            pLeft = pRight;
                            pRight = tmp;
                            tmp = mLeft;
                            mLeft = mRight;
                            mRight = tmp;
                            // iLeft ??
                            //assert false;
                        }
                        assert pLeft.getHeight() <= pRight.getHeight();
                        // exchange left subtree
                        final int other = (pLeft.getChild(0) == mLeft) ? 1 : 0;
                        Node o = pLeft.getChild(other);
                        pLeft.setChild(other, mRight);
                        mRight.parent = pLeft;

                        pLeft.makeDirty(Tree.IS_FILTHY);
                        mRight.makeDirty(Tree.IS_FILTHY);

                        final int rSelf = (pRight.getChild(0) == mRight) ? 0 : 1;
                        pRight.setChild(rSelf, o);
                        o.parent = pRight;

                        pRight.makeDirty(Tree.IS_FILTHY);
                        o.makeDirty(Tree.IS_FILTHY);

                        map[nr] = pLeft;
                    }
                    mapped[nm] = nr;
                    nm += 1;
                }
            }
        }

       // assert nm-1 >= 0 && nm-1 < mapped.length : "" + (nm-1) + " " + mapped.length;
       // assert mapped[nm-1] < map.length : "" + mapped[nm-1] + " " + map.length;

        if( root != map[mapped[nm-1]] ) {
            insureStore();
            anyChanges = true;

            setRoot(map[mapped[nm-1]]);
        }

        if( trackInternalPathChanges ) {
            for (int k = 0; k < nm; ++k) {
                final int nr = mapped[k];
                final Node n = tree.getNode(nr);
                final Node to = map[nr];

                {
                    final int nr1 = to.getNr();
                    if( nodeNumberToBase[nr1] != nr ) {
                        insureStore();
                        nodeNumberToBase[nr1] = nr;
                    }
                }

                if( n.getHeight() != to.getHeight() ) {
                    insureStore();
                    anyChanges = true;
                    to.setHeight(n.getHeight());
                }
            }
        } else {
            for (int k = 0; k < nm; ++k) {
                final int nr = mapped[k];
                final Node n = tree.getNode(nr);
                final Node to = map[nr];

                if( n.getHeight() != to.getHeight() ) {
                    insureStore();
                    anyChanges = true;
                    to.setHeight(n.getHeight());
                }
            }
        }

        ;                                             if( expensiveAsserts ) {  validFilteredTree(this, m_tree.get()); }

        // node is dirty but only branch length to parent changed, and parent is not part of pruned tree.
        // too many marked nodes (bugs)
        if( !anyChanges && !first ) {
            skipY += 1;
            return false;
        }
        first = false;
        hasStartedEditing = true; // make dirty for users
        return true;
    }

    public int baseNode(int n) {
        return nodeNumberToBase[n];
    }

    public boolean onPath(int k) {
        return baseNodesOnPrunedPath[k];
    }

    // calling this is guaranteed to work only at the right time - i.e. during requiresCalculation after rq was called
    // for the pruned tree
    public boolean anyPathChange() {
        return anyPathChanges;
        //return ! Arrays.equals(baseNodesOnPrunedPath, baseNodesOnPrunedPathHelper);
    }

    //private boolean isReady = true;

    private boolean storeCalledThisCycle = false;

    protected void store() {
        storeCalledThisCycle = false;
    }

    private void insureStore() {
        if( ! storeCalledThisCycle ) {
            super.store();
            if( trackInternalPathChanges ) {
                System.arraycopy(nodeNumberToBase, 0, nodeNumberToBaseStore, 0, nodeNumberToBaseStore.length);
            }
            storeCalledThisCycle = true;
        }
    }

    protected void accept() {
        //assert isReady;
        storeCalledThisCycle = false;
        super.accept();
    }

    public void restore() {
        // assert isReady;
        if( storeCalledThisCycle ) {
            storeCalledThisCycle = false;
            super.restore();
            if( trackInternalPathChanges ) {
                int[] tmp = nodeNumberToBase;
                nodeNumberToBase = nodeNumberToBaseStore;
                nodeNumberToBaseStore = tmp;
            }
        }
    }

    static boolean validFilteredTree(PrunedTree pruned, TreeInterface source) {
        Node[] post = source.listNodesPostOrder(null, null);

        Map<String, Node> taxaMap = new HashMap<>();

        for (Node n : pruned.getExternalNodes()) {
            taxaMap.put(n.getID(), n);
        }
        Node[] map = new Node[source.getNodeCount()];
        boolean[] mapb = new boolean[source.getNodeCount()];

        for (final Node n : post) {
            final int nr = n.getNr();
            mapb[nr] = false;

            if( n.isLeaf() ) {
                Node m = taxaMap.get(n.getID());
                if( m == null ) {
                    // not
                    map[nr] = null;
                } else {
                    map[nr] = m;
                    mapb[nr] = true;
                }
            } else {
                // internal
                final Node l = n.getLeft();
                final Node r = n.getRight();

                final int iLeft = l.getNr();
                final int iRight = r.getNr();

                Node mLeft = map[iLeft];
                Node mRight = map[iRight];

                if( mLeft == null ) {
                    map[nr] = mRight;
                } else if( mRight == null ) {
                    map[nr] = mLeft;
                } else {
                    // both mapped
                    final Node pLeft = mLeft.getParent();
                    final Node pRight = mRight.getParent();

                    if( pLeft != pRight ) {
                        return false;
                    }
                    if( n.getHeight() != pLeft.getHeight() ) {
                        return false;
                    }
                    map[nr] = pLeft;
                    mapb[nr] = true;
                }
            }
        }

        if( pruned.trackInternalPathChanges ) {
            for (int k = 0; k < map.length; ++k) {
                if( mapb[k] ) {
                    final Node n = map[k];
                    assert (n != null);
                    if( pruned.nodeNumberToBase[n.getNr()] != k ) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
