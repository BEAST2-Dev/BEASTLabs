package beast.evolution.tree;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import beast.base.core.Description;
import beast.base.core.Input;
import beast.base.evolution.alignment.TaxonSet;
import beast.base.evolution.tree.Node;
import beast.base.evolution.tree.Tree;
import beast.base.evolution.tree.TreeInterface;

@Description("The binary tree generated by pruning a fixed subset of taxa from a source binary tree. "
		+ "Supposed to be more robust but less efficient than PrunedTree"
		+ "and not suitable for PrunedRelaxedClocks.")
public class SimplePrunedTree extends Tree {
	public Input<Tree> treeInput = new Input<Tree>("tree", "source tree to filter/prune.");

	// private int[] leafsToBaseLeafs;
	private int[] baseLeafsToLeafs;
	Tree tree;
	
	@Override
	public void initAndValidate() {
		tree = treeInput.get();
		final TaxonSet treeTaxa = tree.getTaxonset();

		List<String> taxaNames = m_taxonset.get().asStringList();

		if (!treeTaxa.containsAll(taxaNames)) {
			throw new IllegalArgumentException("Taxa is not a subset of base tree taxa.");
		}

		final int nTaxa = taxaNames.size();

		// leafsToBaseLeafs = new int[nTaxa];
		baseLeafsToLeafs = new int[treeTaxa.getTaxonCount()];
		Arrays.fill(baseLeafsToLeafs, -1);

		root = initTree(tree, taxaNames);
		leafNodeCount = nTaxa;
		nodeCount = leafNodeCount * 2 - 1;
		internalNodeCount = leafNodeCount - 1;

		initArrays();
	}

	private Node initTree(TreeInterface tree, List<String> taxaNames) {
		Set<String> tax = new HashSet<>(taxaNames);
		final int nTaxa = taxaNames.size();
		int[] nodeNumber2Source = new int[2 * nTaxa - 1];
		Node[] nodes = new Node[2 * nTaxa - 1];
		Node root = buildTree(tree.getRoot(), tax, new int[]{0}, new int[]{taxaNames.size()}, nodes, nodeNumber2Source);

		// ensure that node numbers are consistent over stop and resume.
		// Node numbers are assigned so that their sort order is identical to
		// the sort
		// order of their source nodes.

		// i = 0..nTaxa-1
		final Integer[] i = new Integer[nodeNumber2Source.length];
		for (int k = 0; k < i.length; ++k) {
			i[k] = k;
		}

		Arrays.sort(i, (o1, o2) -> nodeNumber2Source[o1] - nodeNumber2Source[o2]);
		for (int k = 0; k < i.length; ++k) {
			nodes[k].setNr(k);
			assert nodes[k].isLeaf() == k < nTaxa;
		}

		return root;
	}


	private Node buildTree(Node base, Set<String> taxaNames, int[] leafNodeCount, int[] internalNodeCount, Node[] nodes,
			int[] nodeNumber2Source) {
		Node n;
		if (base.isLeaf()) {
			if (taxaNames.contains(base.getID())) {
				n = newNode();
				n.setNr(leafNodeCount[0]);
				// leafsToBaseLeafs[leafNodeCount[0]] = base.getNr();
				baseLeafsToLeafs[base.getNr()] = leafNodeCount[0];

				leafNodeCount[0] += 1;
				n.setID(base.getID());
			} else {
				n = null;
			}
		} else {
			Node left = buildTree(base.getLeft(), taxaNames, leafNodeCount, internalNodeCount, nodes,
					nodeNumber2Source);
			Node right = buildTree(base.getRight(), taxaNames, leafNodeCount, internalNodeCount, nodes,
					nodeNumber2Source);
			if (left == null) {
				return right;
			}
			if (right == null) {
				return left;
			}
			n = newNode();
			n.setNr(internalNodeCount[0]);
			internalNodeCount[0] += 1;
			n.setLeft(left);
			n.setRight(right);
			left.setParent(n, false);
			right.setParent(n, false);
		}

		if (n != null) {
			n.setHeight(base.getHeight());
			nodes[n.getNr()] = n;
			nodeNumber2Source[n.getNr()] = base.getNr();
		}
		return n;
	}

	
	private Node buildTree(Node base, int[] internalNodeCount) {
		Node n;
		if (base.isLeaf()) {
			int nr = base.getNr();
			if (baseLeafsToLeafs[nr] >= 0) {
				n = m_nodes[baseLeafsToLeafs[nr]];
			} else {
				n = null;
			}
		} else {
			Node left = buildTree(base.getLeft(), internalNodeCount);
			Node right = buildTree(base.getRight(), internalNodeCount);
			if (left == null) {
				return right;
			}
			if (right == null) {
				return left;
			}
			n = m_nodes[internalNodeCount[0]];
			internalNodeCount[0] += 1;
			n.setLeft(left);
			n.setRight(right);
			left.setParent(n, false);
			right.setParent(n, false);
		}

		if (n != null) {
			n.setHeight(base.getHeight());
		}
		return n;
	}
	
	@Override
	protected boolean requiresRecalculation() {
		root = buildTree(tree.getRoot(), new int[]{leafNodeCount});
		return super.requiresRecalculation();
	}

}
